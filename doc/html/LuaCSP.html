<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>LuaCSP Reference Manual 0.1</title><link rel="stylesheet" href="LuaCSP.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="LuaCSP Reference Manual 0.1"><div class="titlepage"><div><div><h2 class="title"><a name="manual"></a>LuaCSP Reference Manual 0.1</h2></div><div><p class="copyright">Copyright © 2012, 2013 Alexey Baskakov</p></div><div><div class="legalnotice" title="Legal Notice"><a name="manual.legal"></a><p>
        Distributed under GNU General Public License (GPL), Version 2.0.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#manual.introduction">1. Introduction</a></span></dt><dt><span class="section"><a href="#manual.the_language">2. The Language</a></span></dt><dd><dl><dt><span class="section"><a href="#manual.the_language.origins">Origins. Communicating Sequential
      Processes (CSP)</a></span></dt><dt><span class="section"><a href="#manual.the_language.channels">Channels</a></span></dt><dt><span class="section"><a href="#manual.the_language.fundamentalOperations">Fundamental
      Operations</a></span></dt><dt><span class="section"><a href="#manual.the_language.composition">Composition of Processes</a></span></dt><dd><dl><dt><span class="section"><a href="#manual.the_language.composition.seq">Sequential Composition</a></span></dt><dt><span class="section"><a href="#manual.the_language.composition.par">Parallel Composition</a></span></dt><dt><span class="section"><a href="#manual.the_language.composition.alt">Alt Composition</a></span></dt><dt><span class="section"><a href="#manual.the_language.composition.flow">Computational
        Flow</a></span></dt></dl></dd><dt><span class="section"><a href="#manual.the_language.api_examples">Domain-Specific API
      Examples</a></span></dt><dt><span class="section"><a href="#manual.the_language.contracts">Contracts</a></span></dt><dt><span class="section"><a href="#manual.the_language.termination">Termination</a></span></dt><dt><span class="section"><a href="#manual.the_language.swarm">Swarms and Go</a></span></dt><dt><span class="section"><a href="#manual.the_language.misc">Miscellaneous Functions</a></span></dt></dl></dd><dt><span class="section"><a href="#manual.advanced">3. Advanced Topics</a></span></dt><dd><dl><dt><span class="section"><a href="#manual.advanced.evaluation">Evaluation Precedence</a></span></dt><dt><span class="section"><a href="#manual.advanced.patterns">Best Programming Practices,
      Patterns and Idioms</a></span></dt></dl></dd><dt><span class="section"><a href="#manual.embedding">4. Embedding and Extending The Language</a></span></dt><dd><dl><dt><span class="section"><a href="#manual.embedding.writing_fundamental_operations">Writing
      Your Own Fundamental Operations</a></span></dt><dt><span class="section"><a href="#manual.embedding.writing_fundamental_operations_lua">Writing
      Fundamental Operations in Plain Lua</a></span></dt><dt><span class="section"><a href="#manual.embedding.api">The Application Program Interface</a></span></dt></dl></dd><dt><span class="section"><a href="#manual.additional_notes">5. Additional Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#manual.additional_notes.disclaimer">Implementation Disclaimer</a></span></dt><dt><span class="section"><a href="#manual.additional_notes.areas">Application Areas</a></span></dt></dl></dd><dt><span class="section"><a href="#manual.faq">6. Frequently Asked Questions</a></span></dt><dt><span class="section"><a href="#manual.roadmap">7. Development Roadmap</a></span></dt></dl></div><div class="section" title="1. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.introduction"></a><a class="link" href="#manual.introduction" title="1. Introduction">1. Introduction</a></h2></div></div></div><p>
      The world is parallel. If we want to write programs that behave as other objects
      behave in the real world, then these programs will have a concurrent structure.
      Moreover, the structure must be executable and debuggable. A LuaCSP program
      models how we think and interact.
    </p><p>
      The idea to express commands or simulation events as a sequence of operations
      is very natural for programmers. However, general procedural programming languages
      tend to execute the instructions in "as fast as possible" fashion.
      When the time comes for time-spreaded real world simulations or interaction
      with the environment in robotics, such concepts as finite state machines or
      event-driven programming are applicable. Those concepts can be implemented
      very efficiently but the resulting model logic is quite fragmented, as the
      scheduling and the evaluation of conditions are scattered throughout the event
      routines.
    </p><p>
      The LuaCSP framework designed to support natural control flow via parallel
      composition of domain-specific time-spreaded operations. It's up to extender
      to implement such operations and to define logical time frame semantics in
      each of them.
    </p><p>
      LuaCSP is a different language. Although it contains Lua as a subset, it has
      unusual properties that make effective LuaCSP programs different in character
      from programs written in its relatives. A straightforward translation of a
      C++ or Lua program into LuaCSP is unlikely to produce a satisfactory result
      - Lua programs are written in Lua (or even more, in the subset of Lua heavily
      influenced by C/C++ minded style), not LuaCSP. Moreover, thinking about the
      problem from a LuaCSP perspective can produce a successful and very different
      program. In other words, to write LuaCSP code well, it's important to understand
      its properties and idioms. It's also important to know the established conventions
      for programming in LuaCSP, such as naming, formatting, program construction,
      and so on, so that programs you write will be easy to understand for other
      LuaCSP programmers. This document gives tips for writing clear, idiomatic LuaCSP
      code.
    </p></div><div class="section" title="2. The Language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.the_language"></a><a class="link" href="#manual.the_language" title="2. The Language">2. The Language</a></h2></div></div></div><div class="section" title="Origins. Communicating Sequential Processes (CSP)"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.origins"></a><a class="link" href="#manual.the_language.origins" title="Origins. Communicating Sequential Processes (CSP)">Origins. Communicating Sequential
      Processes (CSP)</a></h3></div></div></div><p>
        Concurrency and multi-threaded programming have a reputation for difficulty.
        The problem is due partly to complex designs such as proto threads and partly
        to overemphasis on low-level details such as mutexes, condition variables,
        and even memory barriers.
      </p><p>
        One of the most successful models for providing high-level linguistic support
        for concurrency comes from Tony Hoare's Communicating Sequential Processes
        (CSP). CSP is a process algebra which is used to describe parallel programs.
        Erlang, Stackless Python, Newsqueak and Google Go are well known languages
        that stem from CSP. LuaCSP's concurrency primitives derive from orginal Hoare's
        Occam Programming Language, whose main contribution is the powerful notion
        of channels as first class objects.
      </p><p>
        One way to think about CSP model is to consider a typical single-threaded
        program running on a single CPU core. It has no need for synchronization
        primitives. Now run another such instance. It needs no synchronization as
        well. Now let those two communicate via channel. If the communication is
        the synchronizer, there's still no need for other synchronization.
      </p></div><div class="section" title="Channels"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.channels"></a><a class="link" href="#manual.the_language.channels" title="Channels">Channels</a></h3></div></div></div><p>
        In LuaCSP, a program is a network of processes, which are connected using
        channels.
      </p><p>
        A channel is a point-to-point, uni-directional, synchronous unbuffered communications
        link. Processes only need to be aware of the channels connecting them to
        other processes, and how to communicate on those channels (generally using
        the same protocol as the process on the other end).
      </p><p>
        The nature of channels means that the communication is (considered) instantaneous,
        and takes place when both the inputting and outputting processes have reached
        the communication statement. The first process to arrive at a channel will
        wait for the second one. When the second process arrives, it wakes the other
        one up, the data is copied and both processes carry on as before.
      </p><p>
        A process in LuaCSP has a simple model: it is a function executing in parallel
        with other processes in the same address space. In fact, it is a lightweight
        Lua coroutine, costing little more than the allocation of stack space.
      </p><p>
        Consider the example for two processes, 'foo' and 'bar', connected by a channel
        'ch' where 'foo' outputs something down the channel, and where 'bar' reads
        something from the channel:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">ch</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="number">42</span> <span class="special">)</span>
<span class="identifier">end</span>

<span class="identifier">function</span> <span class="identifier">bar</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">v</span> <span class="special">=</span> <span class="identifier">ch</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Unlike Lua, LuaCSP has a notion of a 'main' program, which is a root process.
        All the other sub-processes can be spawned from main or it's sub-procedures.
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">main</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        In order to construct a channel you should call:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">main</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">ch</span> <span class="special">=</span> <span class="identifier">Channel</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Channel is a garbage-collectable object so there is no need to destroy it
        explicitly. As mentioned above, channel introduces two member functions:
        IN and OUT. These two functions are fundamental operations and fall under
        the umbrella of communication. Channels are uni-directional, unbuffered and
        synchronised "wires". When one process communicates on a channel,
        it will block until the other party engages in the communication. At that
        moment, the data is transferred and both processes continue.
      </p></div><div class="section" title="Fundamental Operations"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.fundamentalOperations"></a><a class="link" href="#manual.the_language.fundamentalOperations" title="Fundamental Operations">Fundamental
      Operations</a></h3></div></div></div><p>
        LuaCSP includes Lua as a subset. It means that statements and expressions
        work the same way. In addition, LuaCSP uses a notion of 'fundamental operations'
        - functions with implicit 'yield' inside. Fundamental operation is a function
        that lasts for a specific amount of time defined directly or indirectly in
        a function call arguments. Fundamental operations are atoms (smallest building
        blocks) for composition in LuaCSP.
      </p><p>
        The most simple example is SLEEP, a system function which just sleeps for
        specified amount of seconds:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">main</span><span class="special">()</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">10</span><span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        This manual uses a coding convension with all the fundamental operations
        named in capital letters. As you can see now, IN and OUT functions for channels
        are fundamental operations as well.
      </p><p>
        It's the main task for extender of LuaCSP: to create domain-specific language
        via wrapping her base C/C++ code in a composable set of LuaCSP's fundamental
        operations (see <a class="xref" href="#manual.embedding.writing_fundamental_operations" title="Writing Your Own Fundamental Operations">Writing
      Your Own Fundamental Operations</a>). As a result,
        LuaCSP framework defines three conceptual levels, as shown in the picture
        below:
      </p><p>
        <a class="ulink" href="images/csp_framework_layers.png" target="_top"><span class="inlinemediaobject"><img src="images/csp_framework_layers_small.png" alt="csp_framework_layers_small"></span></a>
      </p></div><div class="section" title="Composition of Processes"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.composition"></a><a class="link" href="#manual.the_language.composition" title="Composition of Processes">Composition of Processes</a></h3></div></div></div><p>
        The IN and OUT processes aren't much use on their own, so several ways of
        putting processes together are provided.
      </p><div class="section" title="Sequential Composition"><div class="titlepage"><div><div><h4 class="title"><a name="manual.the_language.composition.seq"></a><a class="link" href="#manual.the_language.composition.seq" title="Sequential Composition">Sequential Composition</a></h4></div></div></div><p>
          Sequential composition of proccesses is the basic one. LuaCSP leverages
          Lua's default semantics to run expressions for that, so all your processes
          will be executed from top to bottom as in standard Lua:
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">ch2</span> <span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">d</span> <span class="special">=</span> <span class="number">10</span>
	<span class="identifier">ch1</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">d</span><span class="special">,</span> <span class="string">"hello"</span> <span class="special">)</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">10</span><span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">v1</span><span class="special">,</span> <span class="identifier">v2</span> <span class="special">=</span> <span class="identifier">ch2</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          In the example below, the function will run for 10+20+10*1=40 seconds in
          total.
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">bar</span><span class="special">()</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">10</span><span class="special">)</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">20</span><span class="special">)</span>
	<span class="keyword">for</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">,</span><span class="number">10</span> <span class="keyword">do</span>
		<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">1</span><span class="special">)</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>
</pre><p>
        </p></div><div class="section" title="Parallel Composition"><div class="titlepage"><div><div><h4 class="title"><a name="manual.the_language.composition.par"></a><a class="link" href="#manual.the_language.composition.par" title="Parallel Composition">Parallel Composition</a></h4></div></div></div><p>
          Being a parallel language, LuaCSP has the PAR process constructor. This
          arranges for the processes inside it to be executed in parallel, for example:
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">ch2</span> <span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">x</span> <span class="special">=</span> <span class="number">3</span>
			<span class="identifier">ch1</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">y</span> <span class="special">=</span> <span class="identifier">ch2</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">20</span><span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          In fact, PAR is a function which consumes any number of closures (function
          instances). We can't change Lua syntax, so we use anonymous closures to
          mark separate blocks of code to compose.
        </p><p>
          PAR waits for all sub-processes to complete:
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">bar</span><span class="special">()</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">3</span><span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">1</span><span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">2</span><span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">3</span><span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">4</span><span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          In the example above, the function will run for 3+max(1,2,3)+4=10 seconds
          in total.
        </p><p>
          In other words, there is a barrier synchronisation at the end of a PAR,
          on which all the sub-processes synchronise. As well as synchronising at
          the end of a PAR block, processes may also wish to synchronise with other
          processes at various points during their lifetime. This is normally achieved
          by using channels, which allows two processes to synchronise and communicate
          some data between them. In many programs, the data communicated is not
          used, instead the channel is used purely for synchronisation.
        </p><p>
          Because of the Lua lexical scoping rules, local variables can be freely
          accessed by functions defined inside their scope. A local variable used
          by an inner function is called an upvalue, or external local variable,
          inside the inner function. The Lua implementation (in particular, the garbage
          collector) makes sure the variables referred to by the closure survive
          as long as they are active.
        </p><p>
          Concurrent programming in many environments is made difficult by the subtleties
          required to implement correct access to shared objects. LuaCSP encourages
          a different approach in which shared values are passed around on channels
          and never actively shared by separate Lua threads. If two or more processes
          have no access to the object, data inconsistencies cannot occur, by design.
          To encourage this way of thinking, remember Rob Pyke's slogan:
        </p><p>
          <span class="emphasis"><em>Do not communicate by sharing memory; instead, share memory by
          communicating.</em></span>
        </p><p>
          Although LuaCSP doesn't deny shared variables, a high-level approach, using
          channels to control access makes it easier to write clear, correct programs.
        </p><p>
          So, for PAR statements it's recommended to share channels as the only upvalues
          and hide all the other objects in a process local scope:
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">main</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">ch</span> <span class="special">=</span> <span class="identifier">Channel</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span> <span class="special">---</span> <span class="identifier">shared</span><span class="special">!</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">a</span> <span class="special">=</span> <span class="number">1</span> <span class="special">---</span> <span class="identifier">isolated</span><span class="special">,</span> <span class="identifier">hidden</span>
			<span class="identifier">ch</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">a</span> <span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">b</span> <span class="special">=</span> <span class="identifier">ch</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p></div><div class="section" title="Alt Composition"><div class="titlepage"><div><div><h4 class="title"><a name="manual.the_language.composition.alt"></a><a class="link" href="#manual.the_language.composition.alt" title="Alt Composition">Alt Composition</a></h4></div></div></div><p>
          There is also an ALTernative (external/internal choice) for constructing
          processes. Alting is perhaps one of the most useful features of the LuaCSP
          language (and CSP in general). It allows a process to wait for multiple
          events, but only engage in one of them. In fact, LuaCSP's ALT represents
          Occam's PRI ALT (prioritized ALT), which waits for multiple events then
          selects the first available, giving highest priority to the one at the
          top of the list. The generic syntax for an ALT is trivial:
        </p><p>
</p><pre class="programlisting"><span class="identifier">ALT</span><span class="special">(</span>
	<span class="identifier">guard1</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">process</span> <span class="number">1</span>
	<span class="identifier">end</span>
	<span class="special">,</span>
	<span class="identifier">guard2</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">process</span> <span class="number">2</span>
	<span class="identifier">end</span>
	<span class="special">,</span>
<span class="special">...</span>
	<span class="special">,</span>
	<span class="identifier">guardN</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">process</span> <span class="identifier">N</span>
	<span class="identifier">end</span>
<span class="special">)</span>
</pre><p>
        </p><p>
          In other words, ALT function consumes any number of pairs (guard, function
          closure). The types of guard (event selector) supported are:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              Channel inputs.
            </li><li class="listitem">
              Timeout guards. These simply wait for an absolute time to expire then
              become ready.
            </li><li class="listitem">
              nil (do-nothing) guard.
            </li></ul></div><p>
          Here are some examples:
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">ch2</span><span class="special">,</span> <span class="identifier">ch3</span><span class="special">,</span> <span class="identifier">ch4</span> <span class="special">)</span>
	<span class="identifier">ALT</span><span class="special">(</span>
		<span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span> <span class="special">)</span>
			<span class="identifier">ch3</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span> <span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">ch2</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ch4</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">()</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          In case of channel input guard, the provided corresponding closure receives
          all the input channel data as arguments.
        </p><p>
          <span class="bold"><strong>time</strong></span> is a LuaCSP system function which
          returns <span class="emphasis"><em>absolute</em></span> time in seconds (Lua number):
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">ALT</span><span class="special">(</span>
		<span class="identifier">time</span><span class="special">()</span> <span class="special">+</span> <span class="number">100</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
			<span class="special">---</span> <span class="identifier">timeout</span> <span class="identifier">of</span> <span class="number">100</span> <span class="identifier">seconds</span> <span class="identifier">expired</span><span class="special">!</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">ch</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">v</span> <span class="special">)</span>
			<span class="identifier">log</span><span class="special">(</span> <span class="string">"v="</span><span class="special">,</span> <span class="identifier">v</span> <span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          Working with absolute time instead of relative time intervals is more suitable
          for simulation languages. Typically, a mark on timeline is calculated as
          a result of some predictions. It's more common to give a name to some 'notch'
          in time rather then to an interval.
        </p><p>
          The last example here is that of 'polling':
        </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">ch2</span> <span class="special">)</span>
	<span class="identifier">ALT</span><span class="special">(</span>
		<span class="identifier">ch1</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">v</span> <span class="special">)</span>
			<span class="identifier">ch2</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">v</span> <span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">nil</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">zero</span> <span class="special">=</span> <span class="number">0</span>
			<span class="identifier">ch2</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">(</span> <span class="identifier">zero</span> <span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
        </p><p>
          This code will either find the 'ch1' channel ready, than perform the output
          on 'ch2', or, it will find the 'ch1' channel not ready and output zero
          on the 'ch2' channel. In general, polling is a bad thing. This is because
          most of the time it's not required, the desired result is usually achievable
          through the use of parallelism (PAR), plus some suitable ALT. Sometimes
          however it is desirable, for instance on a loop body whose termination
          is signalled on an incoming channel.
        </p></div><div class="section" title="Computational Flow"><div class="titlepage"><div><div><h4 class="title"><a name="manual.the_language.composition.flow"></a><a class="link" href="#manual.the_language.composition.flow" title="Computational Flow">Computational
        Flow</a></h4></div></div></div><p>
          Of course, any process constructors can be nested, i.e. PAR or ALT can
          contain any number of other PARs and ALTs as sub processes (directly or
          indirectly via functions).
        </p><p>
          The LuaCSP evaluator tries to push the computational flow for current simulation
          tick as further as possible. So, it resolves all the communications via
          channels as separate extra steps during current tick (so called 'greedy'
          concept). The evaluation of tick only stops if there is no more communication
          possible without updating leaf operations with delta time.
        </p><p>
          Note that most of the time, all LuaCSP processes will be blocked waiting
          for something. The power of the model is that we can decompose the complex
          state of the system into independently executing, simple sequences of operations.
          External events will naturally lead to sequencing of the processes through
          their actions by scheduling the associated communications.
        </p></div></div><div class="section" title="Domain-Specific API Examples"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.api_examples"></a><a class="link" href="#manual.the_language.api_examples" title="Domain-Specific API Examples">Domain-Specific API
      Examples</a></h3></div></div></div><p>
        The most simple demonstration for LuaCSP domain specific API is sound playback.
        In the following example, the PLAY function lasts as long, as sound lasts.
        This decouples a composition structure from actual duration of participating
        sound files and allows those files to be edited by non-programmers (sound
        engineers) without corrupting the logic for the dialog:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">dialog</span><span class="special">(</span> <span class="identifier">sound_bank</span><span class="special">,</span> <span class="identifier">variant</span> <span class="special">)</span>
	<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">speech1</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
	<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">speech2</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
	<span class="keyword">if</span> <span class="identifier">variant</span> <span class="identifier">then</span>
		<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">speech3A</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
	<span class="keyword">else</span>
		<span class="keyword">for</span> <span class="identifier">i</span><span class="special">=</span><span class="number">1</span><span class="special">,</span><span class="number">3</span> <span class="keyword">do</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">speech3B</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
		<span class="identifier">end</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Another simple example is mixing audio tracks for your multimedia introduction:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">intro_sound</span><span class="special">(</span> <span class="identifier">sound_bank</span> <span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">crowd</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">comment1</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">comment2</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">announcement1</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
			<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">announcement2</span><span class="special">:</span><span class="identifier">PLAY</span><span class="special">()</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        LuaCSP language can be used not only at high level, but at the level just
        above your FSMs. The following animation examples demonstrate that.
      </p><p>
        Your domain-specific API can include specific channels on object to listen
        the events. Assume that actor is an FSM which manages animations on some
        3D mesh:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">game</span><span class="special">(</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">sound_bank</span> <span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">actor</span><span class="special">:</span><span class="identifier">PLAY_ANIMATION</span><span class="special">(</span><span class="string">"run"</span><span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">step</span> <span class="special">=</span> <span class="identifier">actor</span><span class="special">:</span><span class="identifier">Channel</span><span class="special">(</span><span class="string">"step"</span><span class="special">)</span>
			<span class="identifier">local</span> <span class="identifier">heartbeat</span> <span class="special">=</span> <span class="identifier">actor</span><span class="special">:</span><span class="identifier">Channel</span><span class="special">(</span><span class="string">"heartbeat"</span><span class="special">)</span>
			<span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
				<span class="identifier">ALT</span><span class="special">(</span>
					<span class="identifier">step</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
						<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">running</span><span class="special">.</span><span class="identifier">step</span><span class="special">:</span><span class="identifier">play_and_forget</span><span class="special">()</span>
					<span class="identifier">end</span>
					<span class="special">,</span>
					<span class="identifier">heartbeat</span><span class="special">,</span> <span class="identifier">function</span><span class="special">()</span>
						<span class="identifier">sound_bank</span><span class="special">.</span><span class="identifier">running</span><span class="special">.</span><span class="identifier">heartbeat</span><span class="special">:</span><span class="identifier">play_and_forget</span><span class="special">()</span>
					<span class="identifier">end</span>
				<span class="special">)</span>
			<span class="identifier">end</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        The more advanced technique is to use composition of objects and composition
        of time-spreaded operations on those objects as two orthogonal concepts helping
        each other. In cinematics API for your virtual world you can create a hierarchy
        of camera controllers and blenders. Then, you can operate controller's parameters
        in time (mixing, blending, fade in, fade out). In the code below, camera
        track is external 'animatable' data for all the camera parameters, created
        by non-programmer:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">camera_main</span><span class="special">(</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">actor_bone</span><span class="special">,</span> <span class="identifier">tollerance_settings</span><span class="special">,</span> <span class="identifier">relative_dof_settings</span> <span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">viewport</span> <span class="special">=</span> <span class="identifier">Viewport</span><span class="special">:</span><span class="keyword">new</span><span class="special">(</span> <span class="number">0</span><span class="special">,</span> <span class="number">0</span><span class="special">,</span> <span class="number">1</span><span class="special">,</span> <span class="number">1</span> <span class="special">)</span>	

	<span class="identifier">local</span> <span class="identifier">camera</span> <span class="special">=</span> <span class="identifier">Camera</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>	
	<span class="identifier">viewport</span><span class="special">.</span><span class="identifier">set_camera</span><span class="special">(</span> <span class="identifier">camera</span> <span class="special">)</span>

	<span class="identifier">local</span> <span class="identifier">ctrl1</span> <span class="special">=</span> <span class="identifier">CameraController</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">ctrl2</span> <span class="special">=</span> <span class="identifier">CameraController</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">blender</span> <span class="special">=</span> <span class="identifier">CameraLinearBlend</span><span class="special">:</span><span class="keyword">new</span><span class="special">(</span> <span class="identifier">ctrl1</span><span class="special">,</span> <span class="identifier">ctrl2</span> <span class="special">)</span>

	<span class="identifier">camera</span><span class="special">:</span><span class="identifier">set_controller</span><span class="special">(</span> <span class="identifier">blender</span> <span class="special">)</span>

	<span class="identifier">blender</span><span class="special">:</span><span class="identifier">set_blend</span><span class="special">(</span> <span class="number">0</span> <span class="special">)</span> <span class="special">--</span> <span class="number">0</span> <span class="identifier">means</span> <span class="identifier">ctrl1</span> <span class="identifier">at</span> <span class="identifier">full</span> <span class="identifier">strength</span><span class="special">,</span> <span class="number">1</span> <span class="special">-</span> <span class="identifier">ctrl2</span> <span class="identifier">at</span> <span class="identifier">full</span> <span class="identifier">strength</span><span class="special">.</span>
	
	<span class="identifier">PAR</span><span class="special">(</span>						
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">track1</span> <span class="special">=</span> <span class="identifier">CameraTracks</span><span class="special">.</span><span class="identifier">cinematics_spline1</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
			<span class="identifier">camera_play_track_lookat</span><span class="special">(</span> <span class="identifier">ctrl1</span><span class="special">,</span> <span class="identifier">track1</span><span class="special">,</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">actor_bone</span><span class="special">,</span> <span class="identifier">tollerance_settings</span><span class="special">,</span> <span class="identifier">relative_dof_settings</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">track2</span> <span class="special">=</span> <span class="identifier">CameraTracks</span><span class="special">.</span><span class="identifier">cinematics_maintrack</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
			<span class="identifier">camera_play_track</span><span class="special">(</span> <span class="identifier">ctrl2</span><span class="special">,</span> <span class="identifier">track2</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">transition_seconds1</span> <span class="special">=</span> <span class="number">5</span>
			<span class="identifier">local</span> <span class="identifier">transition_seconds2</span> <span class="special">=</span> <span class="number">3</span>
			<span class="identifier">blender</span><span class="special">:</span><span class="identifier">LINEAR_FADE_TO</span><span class="special">(</span> <span class="number">1.0</span><span class="special">,</span> <span class="identifier">transition_seconds1</span> <span class="special">)</span> <span class="special">--</span> <span class="identifier">fade</span> <span class="identifier">to</span> <span class="number">1.0</span> <span class="identifier">in</span> <span class="number">5</span> <span class="identifier">seconds</span>
			<span class="identifier">blender</span><span class="special">:</span><span class="identifier">EXPONENTIAL_FADE_TO</span><span class="special">(</span> <span class="number">0.0</span><span class="special">,</span> <span class="identifier">transition_seconds2</span> <span class="special">)</span> <span class="special">--</span> <span class="identifier">fade</span> <span class="identifier">back</span> <span class="identifier">to</span> <span class="number">0.0</span> <span class="identifier">in</span> <span class="number">3</span> <span class="identifier">seconds</span>
		<span class="identifier">end</span>		
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Blender is a controller itself. So you can stick blenders and controllers
        into each other, creating a hierarchy. CameraHermiteBlend, CameraBaryCentricBlend,
        CameraCatmullRomBlend are possible options.
      </p><p>
        In the example above, camera_play_track and camera_play_track_lookat could
        be implemented as follows:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">camera_play_track</span><span class="special">(</span> <span class="identifier">ctrl</span><span class="special">,</span> <span class="identifier">track</span> <span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">PLAY_TRACK</span><span class="special">(</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">TRANSLATION_TRACK</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">ROTATION_TRACK</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">DOF_TRACK</span><span class="special">(</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">FOV_TRACK</span><span class="special">(</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        The idea is that you can play multiple tracks on controller but apply or
        mix only certain parameters from those tracks (position, rotation, depth
        of field - DOF, field of view - FOV, etc) Each controller has an array of
        3d matrices inside to support a hierarchy of relative geometric transformations.
        Coordinate-related operations (TRANSLATION, ROTATION) consume one extra parameter
        - a number, the index in that array. So you can organize your modifiers to
        work in world space, actor space, actor's bone space and so on.
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">camera_play_track_lookat</span><span class="special">(</span> <span class="identifier">ctrl</span><span class="special">,</span> <span class="identifier">track</span><span class="special">,</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">actor_bone</span><span class="special">,</span> <span class="identifier">tollerance_settings</span><span class="special">,</span> <span class="identifier">relative_dof_settings</span> <span class="special">)</span>
	<span class="identifier">PAR</span><span class="special">(</span>						
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">PLAY_TRACK</span><span class="special">(</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>				
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">TRANSLATION_TRACK</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">ROTATION_TO_ACTOR</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">actor_bone</span><span class="special">,</span> <span class="identifier">tollerance_settings</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">DOF_TO_ACTOR</span><span class="special">(</span> <span class="identifier">relative_dof_settings</span><span class="special">,</span> <span class="identifier">actor</span><span class="special">,</span> <span class="identifier">actor_bone</span><span class="special">,</span> <span class="identifier">tollerance_settings</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ctrl</span><span class="special">:</span><span class="identifier">FOV_TRACK</span><span class="special">(</span> <span class="identifier">track</span> <span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Here, in addition to camera position taken from track, ROTATION_TO_ACTOR
        and DOF_TO_ACTOR operations make camera controller oriented at specified
        actor. Orientation and DOF from track are ignored. Controller's DOF is set
        to focus at specified actor's bone.
      </p></div><div class="section" title="Contracts"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.contracts"></a><a class="link" href="#manual.the_language.contracts" title="Contracts">Contracts</a></h3></div></div></div><p>
        Channels provide a mechanism for implementing the contract between two different
        pieces of code and also a way to synchronize them. You can think about contract
        as a communication interface. It's often useful to define a set of named
        channels and then pass it around as a single argument. So, the contract is
        just a structure definition for a table of channels:
      </p><p>
</p><pre class="programlisting"><span class="identifier">Stages</span> <span class="special">=</span> <span class="identifier">Contract</span><span class="special">:</span><span class="identifier">table</span><span class="special">()</span>
<span class="identifier">Stages</span><span class="special">.</span><span class="identifier">stage1</span> <span class="special">=</span> <span class="identifier">Channel</span>
<span class="identifier">Stages</span><span class="special">.</span><span class="identifier">stage2</span> <span class="special">=</span> <span class="identifier">Channel</span>
<span class="identifier">Stages</span><span class="special">.</span><span class="identifier">stage3</span> <span class="special">=</span> <span class="identifier">Channel</span> <span class="special">--</span> <span class="number">3</span> <span class="identifier">messages</span>

<span class="identifier">function</span> <span class="identifier">process1</span><span class="special">(</span> <span class="identifier">contract</span> <span class="special">)</span>
	<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage1</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
	<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage2</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
	<span class="keyword">for</span> <span class="identifier">i</span><span class="special">=</span><span class="number">1</span><span class="special">,</span><span class="number">3</span> <span class="keyword">do</span>
		<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage3</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>

<span class="identifier">function</span> <span class="identifier">process2</span><span class="special">(</span> <span class="identifier">contract</span> <span class="special">)</span>
	<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage1</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">()</span>
	<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage2</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">()</span>
	<span class="keyword">for</span> <span class="identifier">i</span><span class="special">=</span><span class="number">1</span><span class="special">,</span><span class="number">3</span> <span class="keyword">do</span>
		<span class="identifier">contract</span><span class="special">.</span><span class="identifier">stage3</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">()</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>

<span class="identifier">function</span> <span class="identifier">start</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">contract</span> <span class="special">=</span> <span class="identifier">Stages</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span> <span class="special">--</span> <span class="identifier">spawn</span> <span class="identifier">channels</span>
	<span class="identifier">PAR</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">process1</span><span class="special">(</span> <span class="identifier">contract</span> <span class="special">)</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">process2</span><span class="special">(</span> <span class="identifier">contract</span> <span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Contracts improve code re-use (you can produce as many instances of your
        contract as you need) and allow you to increase extensibility (you don't
        need to modify all the function definitions in order to add one more argument).
        Typical example for contracts is user input:
      </p><p>
</p><pre class="programlisting"><span class="identifier">UserInput</span> <span class="special">=</span> <span class="identifier">Contract</span><span class="special">:</span><span class="identifier">table</span><span class="special">()</span>
<span class="identifier">UserInput</span><span class="special">.</span><span class="identifier">axis</span> 		<span class="special">=</span> <span class="identifier">Gamepad</span><span class="special">.</span><span class="identifier">Channels</span><span class="special">.</span><span class="identifier">axis</span>
<span class="identifier">UserInput</span><span class="special">.</span><span class="identifier">buttons</span> 	<span class="special">=</span> <span class="identifier">Gamepad</span><span class="special">.</span><span class="identifier">Channels</span><span class="special">.</span><span class="identifier">buttons</span>
<span class="identifier">UserInput</span><span class="special">.</span><span class="identifier">dpad</span> 		<span class="special">=</span> <span class="identifier">Gamepad</span><span class="special">.</span><span class="identifier">Channels</span><span class="special">.</span><span class="identifier">dpad</span>

<span class="identifier">function</span> <span class="identifier">processInput</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">ui</span> <span class="special">=</span> <span class="identifier">UserInput</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">processInput</span> <span class="special">=</span> <span class="keyword">true</span>
	<span class="keyword">while</span> <span class="identifier">processInput</span> <span class="keyword">do</span>
		<span class="identifier">ALT</span><span class="special">(</span>
			<span class="identifier">ui</span><span class="special">.</span><span class="identifier">axis</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">filtered_value</span><span class="special">,</span> <span class="identifier">raw_value</span> <span class="special">)</span>
				<span class="identifier">log</span><span class="special">(</span> <span class="string">"axis:"</span><span class="special">,</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">filtered_value</span><span class="special">,</span> <span class="identifier">raw_value</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">)</span>
			<span class="identifier">end</span>
			<span class="special">,</span>
			<span class="identifier">ui</span><span class="special">.</span><span class="identifier">buttons</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">state</span> <span class="special">)</span>
				<span class="identifier">log</span><span class="special">(</span> <span class="string">"buttons:"</span><span class="special">,</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">state</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">)</span>
			<span class="identifier">end</span>
			<span class="special">,</span>
			<span class="identifier">ui</span><span class="special">.</span><span class="identifier">dpad</span><span class="special">,</span> <span class="identifier">function</span><span class="special">(</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">state</span> <span class="special">)</span>
				<span class="identifier">log</span><span class="special">(</span> <span class="string">"dpad:"</span><span class="special">,</span> <span class="identifier">code</span><span class="special">,</span> <span class="identifier">state</span><span class="special">,</span> <span class="string">"\n"</span> <span class="special">)</span>
			<span class="identifier">end</span>
		<span class="special">)</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>
</pre><p>
      </p></div><div class="section" title="Termination"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.termination"></a><a class="link" href="#manual.the_language.termination" title="Termination">Termination</a></h3></div></div></div><p>
        Correct termination of parallel systems is sometimes thought to be a difficult
        problem: given a sub-network of processes with arbitrary topology, message
        protocol and synchronisation regime, arrange for it to terminate. The initiative
        to kill the system may come from one or more of the processes themselves
        and/or from one or more points outside (if the network is not a closed system).
        This problem has multiple proposed solutions, but even the poison/resetting
        approach and ultra-short processes don't work well.
      </p><p>
        <span class="bold"><strong>How not to do it</strong></span>: Pass a special termination
        channel everywhere. The problem is that every single long lasting operation
        requires to wait a termination signal in parallel to itself (via PAR or ALT).
        This is unacceptable. As we can see from here, termination is non-local effect.
      </p><p>
        <span class="bold"><strong>How not to do it</strong></span>: You might try setting
        a global flag that each process and each fundamental operation polls to see
        if it's time to close down. Main issue stays the same as in previous approach.
        Moreover, an extra problem appears: the order of shut-down of the components
        is very difficult to control.
      </p><p>
        <span class="bold"><strong>How to do it</strong></span>: Let's give any process the
        ability to 'terminate' any child processes. Notice, that we should keep processes
        anonymous (not a first-class values) since it was a key language design decision.
      </p><p>
        Yes, this is not a fully secure feature: this wants child processes to be
        at the mercy of parent (perhaps quite unconnected) process. External termination
        of a sub-network results in deadlock if done wrongly. The pit-fall we have
        to avoid is committing a process to communicate with a terminated neighbour.
        If this were to happen, that communication would never terminate and, therefore,
        the network would never terminate.
      </p><p>
        The decision: trade some security for convenience of declaring most common
        case. LuaCSP introduces the notion of termination scope via PARWHILE construct.
      </p><p>
        PARWHILE syntax is the same as for PAR but semantics is different:
      </p><p>
</p><pre class="programlisting"><span class="identifier">PARWHILE</span><span class="special">(</span>
	<span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">main</span> <span class="identifier">child</span> <span class="identifier">process</span>
	<span class="identifier">end</span>
	<span class="special">,</span>
	<span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">child</span> <span class="identifier">process1</span> <span class="special">(</span><span class="identifier">potential</span> <span class="identifier">termination</span> <span class="identifier">victim</span><span class="special">)</span>
	<span class="identifier">end</span>
	<span class="special">,</span>
<span class="special">...</span>
	<span class="special">,</span>
	<span class="identifier">function</span><span class="special">()</span>
		<span class="special">---</span> <span class="identifier">child</span> <span class="identifier">processN</span> <span class="special">(</span><span class="identifier">potential</span> <span class="identifier">termination</span> <span class="identifier">victim</span><span class="special">)</span>
	<span class="identifier">end</span>
<span class="special">)</span>
</pre><p>
      </p><p>
        PAR operation lasts until any of it's child processes lasts, which is very
        consistent. PARWHILE operation lasts as long as <span class="bold"><strong>the
        process specified first</strong></span> (main child process) lasts.
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">bar</span><span class="special">()</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">3</span><span class="special">)</span>
	<span class="identifier">PARWHILE</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">---</span> <span class="identifier">main</span> <span class="identifier">process</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">3</span><span class="special">)</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">4</span><span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
	<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">5</span><span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        In the example above, the function runs for 3+1+5=9 seconds in total. All
        the secondary proccesses start to operate, but are terminated within 1 second.
        In terms of Lua implementation: if first PARWHILE coroutine successfully
        exits, all the rest PARWHILE coroutines will never be resumed and later will
        be collected by the garbage-collector as any other Lua object.
      </p><p>
        This enables you to use functions with no return (lasting forever, at first
        glance):
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">PARWHILE</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ch</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
				<span class="special">...</span>
				<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
			<span class="identifier">end</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        The semantics of SLEEP(0) is "sleep until next update (simulation tick)".
        The above proposed approach allows a programmer to 'fill' an unknown amount
        of time with some useful activities while waiting for some special event,
        which is quite natural.
      </p><p>
        If a process needs to be closed down, it must be given the opportunity to
        perform whatever termination activities are essential to maintain a clean
        system environment. In most simple case you can put clean-up code right before
        the end of your main child process, i.e.:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">PARWHILE</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ch</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
			<span class="special">---</span> <span class="identifier">put</span> <span class="identifier">clean</span> <span class="identifier">up</span> <span class="identifier">code</span> <span class="identifier">here</span><span class="special">!!!</span>
		<span class="identifier">end</span>
		<span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
				<span class="special">...</span>
				<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
			<span class="identifier">end</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        In high-level LuaCSP you don't need to worry about clean-up, which is really
        a low-level task. In LuaCSP you have to operate in terms of fundamental operations
        written either in C++ or standard 'immediate' Lua. As a consequence, your
        fundamental operations are responsible for resources clean-up, which is a
        topic highlighted in this section: <a class="xref" href="#manual.embedding.writing_fundamental_operations" title="Writing Your Own Fundamental Operations">Writing
      Your Own Fundamental Operations</a>.
      </p></div><div class="section" title="Swarms and Go"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.swarm"></a><a class="link" href="#manual.the_language.swarm" title="Swarms and Go">Swarms and Go</a></h3></div></div></div><p>
        Sometimes it's useful to start a new process in fire-and-forget style (like
        'go' command in the Google's Go language). However, the termination aspect
        is still applicable for such processes. LuaCSP introduces the notion of swarm.
        Swarm is a garbage-collectable object, which represents a group of asyncronously
        started coroutines:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">foo</span><span class="special">(</span> <span class="identifier">ch</span> <span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">swarm</span> <span class="special">=</span> <span class="identifier">Swarm</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>

	<span class="identifier">PARWHILE</span><span class="special">(</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">ch</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">swarm</span><span class="special">:</span><span class="identifier">MAIN</span><span class="special">()</span>
		<span class="identifier">end</span><span class="special">,</span>
		<span class="identifier">function</span><span class="special">()</span>
			<span class="identifier">local</span> <span class="identifier">ch2</span> <span class="special">=</span> <span class="identifier">Channel</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
			<span class="identifier">swarm</span><span class="special">:</span><span class="identifier">go</span><span class="special">(</span>
				<span class="identifier">function</span><span class="special">()</span>
					<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">10</span><span class="special">)</span>
				<span class="identifier">end</span><span class="special">,</span>
				<span class="identifier">function</span><span class="special">()</span>
					<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">20</span><span class="special">)</span>
					<span class="identifier">ch2</span><span class="special">:</span><span class="identifier">IN</span><span class="special">()</span>
				<span class="identifier">end</span>
			<span class="special">)</span>
			<span class="identifier">swarm</span><span class="special">:</span><span class="identifier">go</span><span class="special">(</span>
				<span class="identifier">function</span><span class="special">()</span>
					<span class="identifier">SLEEP</span><span class="special">(</span><span class="number">10</span><span class="special">)</span>
				<span class="identifier">end</span><span class="special">,</span>
				<span class="identifier">function</span><span class="special">()</span>
					<span class="identifier">ch2</span><span class="special">:</span><span class="identifier">OUT</span><span class="special">()</span>
				<span class="identifier">end</span>
			<span class="special">)</span>
			<span class="identifier">log</span><span class="special">(</span><span class="string">"finished!\n"</span><span class="special">)</span>
		<span class="identifier">end</span>
	<span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        This example spawns four 'go' processes without any waitings. Notice that
        swarm:MAIN() function call will never return, because it's only purpose is
        to be terminated with outer PARWHILE construct. If that happens, all the
        swarm coroutines started with swarm:go command are terminated. And of course,
        swarm processes can communicate with outer process network via channels using
        standard LuaCSP rules.
      </p></div><div class="section" title="Miscellaneous Functions"><div class="titlepage"><div><div><h3 class="title"><a name="manual.the_language.misc"></a><a class="link" href="#manual.the_language.misc" title="Miscellaneous Functions">Miscellaneous Functions</a></h3></div></div></div><p>
        TBD
      </p></div></div><div class="section" title="3. Advanced Topics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.advanced"></a><a class="link" href="#manual.advanced" title="3. Advanced Topics">3. Advanced Topics</a></h2></div></div></div><div class="section" title="Evaluation Precedence"><div class="titlepage"><div><div><h3 class="title"><a name="manual.advanced.evaluation"></a><a class="link" href="#manual.advanced.evaluation" title="Evaluation Precedence">Evaluation Precedence</a></h3></div></div></div><p>
        TBD
      </p></div><div class="section" title="Best Programming Practices, Patterns and Idioms"><div class="titlepage"><div><div><h3 class="title"><a name="manual.advanced.patterns"></a><a class="link" href="#manual.advanced.patterns" title="Best Programming Practices, Patterns and Idioms">Best Programming Practices,
      Patterns and Idioms</a></h3></div></div></div><p>
        TBD
      </p></div></div><div class="section" title="4. Embedding and Extending The Language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.embedding"></a><a class="link" href="#manual.embedding" title="4. Embedding and Extending The Language">4. Embedding and Extending The Language</a></h2></div></div></div><div class="section" title="Writing Your Own Fundamental Operations"><div class="titlepage"><div><div><h3 class="title"><a name="manual.embedding.writing_fundamental_operations"></a><a class="link" href="#manual.embedding.writing_fundamental_operations" title="Writing Your Own Fundamental Operations">Writing
      Your Own Fundamental Operations</a></h3></div></div></div><p>
        LuaCSP provides a C++ abstract class for all fundamental operations called
        Operation:
      </p><p>
</p><pre class="programlisting"><span class="keyword">class</span> <span class="identifier">Operation</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="keyword">virtual</span> <span class="identifier">WorkResult</span><span class="special">::</span><span class="identifier">Enum</span> <span class="identifier">Work</span><span class="special">(</span> <span class="identifier">Host</span><span class="special">&amp;</span> <span class="identifier">host</span><span class="special">,</span> <span class="identifier">CspTime_t</span> <span class="identifier">dt</span> <span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>	
	<span class="keyword">virtual</span> <span class="keyword">int</span> <span class="identifier">PushResults</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">luaStack</span> <span class="special">);</span>
	<span class="keyword">void</span> <span class="identifier">SetFinished</span><span class="special">(</span> <span class="keyword">bool</span> <span class="identifier">finished</span> <span class="special">);</span>
<span class="special">...</span>

<span class="keyword">private</span><span class="special">:</span>
	<span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">Init</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">,</span> <span class="identifier">InitError</span><span class="special">&amp;</span> <span class="identifier">initError</span> <span class="special">);</span>
	<span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">Terminate</span><span class="special">(</span> <span class="identifier">Host</span><span class="special">&amp;</span> <span class="identifier">host</span> <span class="special">);</span>
<span class="special">...</span>
<span class="special">};</span>
</pre><p>
      </p><p>
        Consider the following declaration for your custom SLEEP:
      </p><p>
</p><pre class="programlisting"><span class="keyword">class</span> <span class="identifier">OpSleep</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">Operation</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
	<span class="identifier">OpSleep</span><span class="special">();</span>

<span class="keyword">private</span><span class="special">:</span>
	<span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="identifier">Init</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">,</span> <span class="identifier">InitError</span><span class="special">&amp;</span> <span class="identifier">initError</span> <span class="special">);</span>
	<span class="keyword">virtual</span> <span class="identifier">WorkResult</span><span class="special">::</span><span class="identifier">Enum</span> <span class="identifier">Work</span><span class="special">(</span> <span class="identifier">Host</span><span class="special">&amp;</span> <span class="identifier">host</span><span class="special">,</span> <span class="identifier">CspTime_t</span> <span class="identifier">dt</span> <span class="special">);</span>

	<span class="keyword">float</span> <span class="identifier">m_seconds</span><span class="special">;</span>
<span class="special">};</span>
</pre><p>
      </p><p>
        ... and the implementation (don't forget about un-typed to typed code conversions,
        error handling and reporting):
      </p><p>
</p><pre class="programlisting"><span class="identifier">OpSleep</span><span class="special">::</span><span class="identifier">OpSleep</span><span class="special">()</span>
	<span class="special">:</span> <span class="identifier">m_seconds</span><span class="special">()</span>
<span class="special">{</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">OpSleep</span><span class="special">::</span><span class="identifier">Init</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">,</span> <span class="identifier">InitError</span><span class="special">&amp;</span> <span class="identifier">initError</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span><span class="identifier">args</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">IsNumber</span><span class="special">()</span> <span class="special">)</span>
		<span class="keyword">return</span> <span class="identifier">initError</span><span class="special">.</span><span class="identifier">ArgError</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="string">"seconds expected"</span> <span class="special">);</span>

	<span class="identifier">m_seconds</span> <span class="special">=</span> <span class="identifier">args</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">GetNumber</span><span class="special">();</span>
	<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">WorkResult</span><span class="special">::</span><span class="identifier">Enum</span> <span class="identifier">OpSleep</span><span class="special">::</span><span class="identifier">Work</span><span class="special">(</span> <span class="identifier">Host</span><span class="special">&amp;,</span> <span class="identifier">CspTime_t</span> <span class="identifier">dt</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="identifier">m_seconds</span> <span class="special">-=</span> <span class="identifier">dt</span><span class="special">;</span>
	<span class="keyword">return</span> <span class="identifier">m_seconds</span> <span class="special">&gt;</span> <span class="number">0</span> <span class="special">?</span> <span class="identifier">WorkResult</span><span class="special">::</span><span class="identifier">YIELD</span> <span class="special">:</span> <span class="identifier">WorkResult</span><span class="special">::</span><span class="identifier">FINISH</span><span class="special">;</span>
<span class="special">}</span>
</pre><p>
      </p><p>
        The Work function is called once a simulation tick and it must return one
        of the following WorkResult::Enum values:
      </p><p>
</p><pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">WorkResult</span>
<span class="special">{</span>
	<span class="keyword">enum</span> <span class="identifier">Enum</span>
	<span class="special">{</span>
		  <span class="identifier">FINISH</span> <span class="special">=</span> <span class="number">0</span> <span class="comment">// return from operation, resume coroutine</span>
		<span class="special">,</span> <span class="identifier">YIELD</span>	<span class="comment">// do not return for now, continue to work</span>
	<span class="special">};</span>
<span class="special">}</span>
</pre><p>
      </p><p>
        Terminate function is called on your operation termination. Override it,
        if your operation needs to close or stop any resources. This is a place to
        stop a sound in your PLAY_SOUND operation, for instance.
      </p><p>
        In Init function, your operation must decide, whether it wants to be yielded
        or wants to return to Lua immediately. Consider the following example: there
        are two possible semantics for SLEEP(0) statement. First option: sleep until
        next simulation tick. Second option: do not sleep at all, return immediately.
        So if you want to return from operation on it's start, you should call SetFinished(true)
        in Init function:
      </p><p>
</p><pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">OpSleep</span><span class="special">::</span><span class="identifier">Init</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">args</span><span class="special">,</span> <span class="identifier">InitError</span><span class="special">&amp;</span> <span class="identifier">initError</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="keyword">if</span> <span class="special">(</span> <span class="special">!</span><span class="identifier">args</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">IsNumber</span><span class="special">()</span> <span class="special">)</span>
		<span class="keyword">return</span> <span class="identifier">initError</span><span class="special">.</span><span class="identifier">ArgError</span><span class="special">(</span> <span class="number">1</span><span class="special">,</span> <span class="string">"seconds expected"</span> <span class="special">);</span>

	<span class="identifier">m_seconds</span> <span class="special">=</span> <span class="identifier">args</span><span class="special">[</span><span class="number">1</span><span class="special">].</span><span class="identifier">GetNumber</span><span class="special">();</span>

	<span class="keyword">if</span><span class="special">(</span> <span class="identifier">m_seconds</span> <span class="special">&lt;=</span> <span class="number">0</span> <span class="special">)</span>
		<span class="identifier">SetFinsihed</span><span class="special">(</span> <span class="keyword">true</span> <span class="special">);</span>

	<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>
</pre><p>
      </p><p>
        You have to pay attention to this detail because sometimes it's very important
        to avoid 1-tick stalls in your simulation flow. The problem also exists in
        inaccurate FSM implementations: state switches can be delayed until next
        update if implemented incorrectly. Also, remember that Work will be called
        only on the next tick after operation creation (Init).
      </p><p>
        The final stage. Expose your operation to Lua:
      </p><p>
</p><pre class="programlisting"><span class="keyword">int</span> <span class="identifier">SLEEP</span><span class="special">(</span> <span class="identifier">lua_State</span><span class="special">*</span> <span class="identifier">luaState</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="identifier">OpSleep</span><span class="special">*</span> <span class="identifier">pSleep</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">OpSleep</span><span class="special">();</span>
	<span class="keyword">return</span> <span class="identifier">pSleep</span><span class="special">-&gt;</span><span class="identifier">DoInit</span><span class="special">(</span> <span class="identifier">luaState</span> <span class="special">);</span>
<span class="special">}</span>

<span class="keyword">const</span> <span class="identifier">FunctionRegistration</span> <span class="identifier">operationDescriptions</span><span class="special">[]</span> <span class="special">=</span>
<span class="special">{</span>
	  <span class="string">"SLEEP"</span><span class="special">,</span> <span class="identifier">SLEEP</span>
	<span class="special">,</span> <span class="identifier">NULL</span><span class="special">,</span> <span class="identifier">NULL</span>
<span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">RegisterMyOperations</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaState</span><span class="special">&amp;</span> <span class="identifier">state</span><span class="special">,</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStackValue</span><span class="special">&amp;</span> <span class="identifier">value</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="identifier">RegisterFunctions</span><span class="special">(</span> <span class="identifier">state</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">operationDescriptions</span> <span class="special">);</span>
<span class="special">}</span>

<span class="keyword">void</span> <span class="identifier">UnregisterMyOperations</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaState</span><span class="special">&amp;</span> <span class="identifier">state</span><span class="special">,</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStackValue</span><span class="special">&amp;</span> <span class="identifier">value</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="identifier">UnregisterFunctions</span><span class="special">(</span> <span class="identifier">state</span><span class="special">,</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">operationDescriptions</span> <span class="special">);</span>
<span class="special">}</span>
</pre><p>
      </p><p>
        If you want to return values from your operation, just override PushResults
        method and push arguments onto provided Lua stack. Overridden PushResults
        method should return the number of passed arguments. Consider dummy example:
      </p><p>
</p><pre class="programlisting"><span class="keyword">int</span> <span class="identifier">OpMyDummyOp</span><span class="special">::</span><span class="identifier">PushResults</span><span class="special">(</span> <span class="identifier">lua</span><span class="special">::</span><span class="identifier">LuaStack</span><span class="special">&amp;</span> <span class="identifier">luaStack</span> <span class="special">)</span>
<span class="special">{</span>
	<span class="identifier">luaStack</span><span class="special">.</span><span class="identifier">PushString</span><span class="special">(</span> <span class="string">"hello!"</span> <span class="special">);</span>
	<span class="identifier">luaStack</span><span class="special">.</span><span class="identifier">PushBoolean</span><span class="special">(</span> <span class="keyword">true</span> <span class="special">);</span>
	<span class="keyword">return</span> <span class="number">2</span><span class="special">;</span>
<span class="special">}</span>
</pre><p>
      </p><p>
        It allows one to receive some results in the following way:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">bar</span><span class="special">()</span>
	<span class="identifier">local</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">status</span> <span class="special">=</span> <span class="identifier">MY_DUMMY_OP</span><span class="special">()</span>
	<span class="identifier">log</span><span class="special">(</span> <span class="identifier">str</span><span class="special">,</span> <span class="identifier">status</span> <span class="special">)</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        ... where 'str' will contain "hello!" string and 'status' will
        contain 'true'.
      </p></div><div class="section" title="Writing Fundamental Operations in Plain Lua"><div class="titlepage"><div><div><h3 class="title"><a name="manual.embedding.writing_fundamental_operations_lua"></a><a class="link" href="#manual.embedding.writing_fundamental_operations_lua" title="Writing Fundamental Operations in Plain Lua">Writing
      Fundamental Operations in Plain Lua</a></h3></div></div></div><p>
        Writing a fundamental operation in Plain Lua typically occurs in three steps:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Declare your new operation class.
          </li><li class="listitem">
            Override the methods you need (there are three of them: Work, PushResults
            and Terminate)
          </li><li class="listitem">
            Declare a function to be yielded, i.e. fundamental operation itself.
          </li></ol></div><p>
        Take a look at the following implementaion of SLEEP in Plain Lua:
      </p><p>
</p><pre class="programlisting"><span class="identifier">OpLuaSleep</span> <span class="special">=</span> <span class="identifier">CspOperation</span><span class="special">:</span><span class="identifier">table</span><span class="special">()</span>

<span class="identifier">function</span> <span class="identifier">OpLuaSleep</span><span class="special">:</span><span class="identifier">Work</span><span class="special">(</span> <span class="identifier">deltaTime</span> <span class="special">)</span>
	<span class="identifier">self</span><span class="special">.</span><span class="identifier">seconds</span> <span class="special">=</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">seconds</span> <span class="special">-</span> <span class="identifier">deltaTime</span>
	<span class="keyword">if</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">seconds</span> <span class="special">&gt;</span> <span class="number">0</span> <span class="identifier">then</span>
		<span class="keyword">return</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">Yield</span>
	<span class="keyword">else</span>
		<span class="keyword">return</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">Finish</span>
	<span class="identifier">end</span>
<span class="identifier">end</span>

<span class="identifier">function</span> <span class="identifier">LUA_SLEEP</span><span class="special">(</span> <span class="identifier">seconds</span> <span class="special">)</span>
	<span class="identifier">local</span> <span class="identifier">op</span> <span class="special">=</span> <span class="identifier">OpLuaSleep</span><span class="special">:</span><span class="keyword">new</span><span class="special">()</span>
	<span class="identifier">op</span><span class="special">.</span><span class="identifier">seconds</span> <span class="special">=</span> <span class="identifier">seconds</span>
	<span class="keyword">return</span> <span class="identifier">op</span><span class="special">:</span><span class="identifier">Init</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            OpLuaSleep is a new operation class.
          </li><li class="listitem">
            OpLuaSleep:Work is a method to be called every simulation tick.
          </li><li class="listitem">
            LUA_SLEEP is an API function to be called from LuaCSP code.
          </li></ol></div><p>
        Overridden Work function must return either self.Finish or self.Yield integer
        constant to resume or yield current CSP process.
      </p><p>
        Your API fundamental function (named in capital letters) must create an instance
        of your operation, initialize member parameters (if any) and return operation:Init()
        result as a tail call.
      </p><p>
        If you want your operation to return some results, override the PushResults
        method:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">OpMyComputation</span><span class="special">:</span><span class="identifier">PushResults</span><span class="special">()</span>
	<span class="keyword">return</span> <span class="identifier">self</span><span class="special">.</span><span class="identifier">result</span><span class="special">,</span> <span class="string">"hi"</span><span class="special">,</span> <span class="keyword">true</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Override Terminate method to perform any activities, related to <a class="xref" href="#manual.the_language.termination" title="Termination">Termination</a> in
        PARWHILE scope:
      </p><p>
</p><pre class="programlisting"><span class="identifier">function</span> <span class="identifier">OpSoundPlayback</span><span class="special">:</span><span class="identifier">Terminate</span><span class="special">()</span>
	<span class="identifier">self</span><span class="special">.</span><span class="identifier">sound</span><span class="special">:</span><span class="identifier">Stop</span><span class="special">()</span>
<span class="identifier">end</span>
</pre><p>
      </p><p>
        Notice that the code in overridden methods can't yield.
      </p><p>
        Of course, you should have something to be wrapped, if you want to get some
        sense. Some asyncronous C++/Lua functions with completion callbacks, for
        example.
      </p></div><div class="section" title="The Application Program Interface"><div class="titlepage"><div><div><h3 class="title"><a name="manual.embedding.api"></a><a class="link" href="#manual.embedding.api" title="The Application Program Interface">The Application Program Interface</a></h3></div></div></div><p>
        TBD
      </p></div></div><div class="section" title="5. Additional Notes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.additional_notes"></a><a class="link" href="#manual.additional_notes" title="5. Additional Notes">5. Additional Notes</a></h2></div></div></div><div class="section" title="Implementation Disclaimer"><div class="titlepage"><div><div><h3 class="title"><a name="manual.additional_notes.disclaimer"></a><a class="link" href="#manual.additional_notes.disclaimer" title="Implementation Disclaimer">Implementation Disclaimer</a></h3></div></div></div><p>
        The following priorities were taken (in declining order):
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Extend standard Lua distribution in non-intrusive way (just using allowed
            #defines and API)
          </li><li class="listitem">
            Make LuaCSP to run on every architecture where Lua runs. Minimize the
            usage of complicated C/C++ (exceptions, RTTI, templates, STL, macroses)
          </li><li class="listitem">
            Keep LuaCSP fast and minimalistic.
          </li></ol></div><p>
        Current distribution is based on Lua 5.2. However, it can be easily back-ported
        to Lua 5.1 since LuaCSP doesn't use any specifics.
      </p><p>
        It also should work perfectly with commercial Lua implementations (including
        debugger support) such as <a class="ulink" href="http://www.havok.com/products/script" target="_top">Havok
        script</a> (former KoreVM).
      </p><p>
        A <a class="ulink" href="http://luaplus.org/" target="_top">LuaPlus</a> port would give some speed-up.
        Implementing it isn't a problem as well.
      </p></div><div class="section" title="Application Areas"><div class="titlepage"><div><div><h3 class="title"><a name="manual.additional_notes.areas"></a><a class="link" href="#manual.additional_notes.areas" title="Application Areas">Application Areas</a></h3></div></div></div><p>
        The LuaCSP framework supposed to be used in:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            Video Games Development
            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  High-level game flow: to orchestrate asyncronous loading of packages/assets
                  in pseudo-syncronous way.
                </li><li class="listitem">
                  Gameplay-coupled interactive cut scenes with heavy logic flow.
                </li><li class="listitem">
                  Scripted artificial intelligence (at tactic level: units, at strategic
                  level: groups of units)
                </li><li class="listitem">
                  As a general alternative to finite state machines.
                </li></ul></div>
          </li><li class="listitem">
            Distributed Systems
            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  High-level coordination of network-distributed services and entities.
                </li><li class="listitem">
                  Implementation of a communications protocol for services (requests/responses,
                  handshakes)
                </li><li class="listitem">
                  Deployment scenarios.
                </li></ul></div>
          </li><li class="listitem">
            Quality Assuarance and Test Automation
            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  Automated user input testing (mimicking human user activities according
                  to use case scenarios)
                </li><li class="listitem">
                  Load testing for High load systems (thousands of client/front-end
                  scripted bots, mimicking users of the service)
                </li></ul></div>
          </li><li class="listitem">
            Robotics
            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  Concurrent high-level commands to hardware, concurrent sensors
                  monitoring, decisions coordination.
                </li><li class="listitem">
                  Behavior for groups of robots, in-group coordination.
                </li></ul></div>
          </li><li class="listitem">
            Graphical User Interfaces/Experience
            <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                  Animation for GUI elements and frames (color, screen movement,
                  fade in/out).
                </li><li class="listitem">
                  Generic dispatch of user input.
                </li><li class="listitem">
                  Input gestures recognition, high-level tracking of real world objects
                  in time (Video cameras, Microsoft's Kinect).
                </li><li class="listitem">
                  Interactive multimedia installations.
                </li></ul></div>
          </li></ul></div></div></div><div class="section" title="6. Frequently Asked Questions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.faq"></a><a class="link" href="#manual.faq" title="6. Frequently Asked Questions">6. Frequently Asked Questions</a></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <span class="bold"><strong>Q</strong></span>: Why Lua?
          <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <span class="bold"><strong>A</strong></span>: Lua is embeddable, high-performance,
                minimalistic but highly extensible language. <a class="ulink" href="http://lambda-the-ultimate.org/node/3894" target="_top">Small
                is Beautiful: the design of Lua</a>. See some admirations for
                game development here: <a class="ulink" href="http://gdcvault.com/play/1014795/Havok-Script-Efficient-Lua-Scripting" target="_top">Havok
                Script: Efficient Lua Scripting</a>.
              </li></ul></div>
        </li><li class="listitem">
          <span class="bold"><strong>Q</strong></span>: How fast is it?
          <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <span class="bold"><strong>A</strong></span>: LuaCSP is intended to be used
                in real time systems. Most of the time, all the LuaCSP coroutines
                will be blocked waiting for fundamental operations to complete. So
                it's a matter of balance - you can always move computationally heavy
                code to C++.
              </li></ul></div>
        </li><li class="listitem">
          <span class="bold"><strong>Q</strong></span>: Did you ever hear of Cont Monad?
          <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <span class="bold"><strong>A</strong></span>: Sure. I heard of delimited continuations
                and CPS as well. LuaCSP designed to be a pragmatic tool. It should
                be easy to use and understand for as many programmers as possible.
              </li></ul></div>
        </li><li class="listitem">
          <span class="bold"><strong>Q</strong></span>: Why not pure coroutines?
          <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <span class="bold"><strong>A</strong></span>: Firstly, Lua coroutines represent
                only sequential execution for processes (the letters S and P in CSP).
                So, they lack the communication aspect (the letter C in CSP). Secondly,
                Lua coroutine only suspends/resumes it's execution by explicitly
                calling yield/resume functions. In LuaCSP all the coroutine yields
                are hidden inside the C++ system functions. The domain-specific language
                user sees none of this, which is the point.
              </li></ul></div>
        </li><li class="listitem">
          <span class="bold"><strong>Q</strong></span>: I noticed the Lua 5.2.1 distribution
          in LuaCSP repo. How invasive are your changes?
          <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <span class="bold"><strong>A</strong></span>: LuaCSP comes with unmodified
                Lua distribution except for LUA_NUMBER to be float (including minor
                modifications to avoid warnings while compiling in Microsoft Visual
                C++). There was no invasive changes at all. The only requirement
                is that Lua must be compiled with #define LUAI_EXTRASPACE sizeof(void*)
                option. It allows LuaCSP to have a mapping from Lua thread to some
                internal C++ object.
              </li></ul></div>
        </li></ul></div></div><div class="section" title="7. Development Roadmap"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="manual.roadmap"></a><a class="link" href="#manual.roadmap" title="7. Development Roadmap">7. Development Roadmap</a></h2></div></div></div><p>
      Reacting to user requests is priority number one. Next:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          Write very first working vertical slice (almost done).
        </li><li class="listitem">
          Write the comprehensive manual (in progress).
        </li><li class="listitem">
          Implement basic, low-level samples.
        </li><li class="listitem">
          Make it fully test-driven.
        </li><li class="listitem">
          Implement extra language features (pluto-like serialization, google-go
          like FIFO for multiple producers/consumers on one channel)
        </li><li class="listitem">
          Perform obvious optimizations (no heap allocs, memory pools, variants everywhere
          etc)
        </li><li class="listitem">
          Implement comprehensive, high-level sample.
        </li><li class="listitem">
          Portability, cross-platform support (x64, cmake)
        </li></ol></div></div></div></body></html>
